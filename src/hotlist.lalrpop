use std::str::FromStr;

use lalrpop_util::ParseError;
use version_compare::version::Version as RefVersion;

use crate::ast;
use crate::lexer;

grammar<'input>(input: &'input str);

pub HotlistHeader: ast::HotList<'input> = {
    <version:HotlistVersion> <options:HotlistOptions> => {
        ast::HotList {
            version,
            options,
            entries: Vec::<ast::EntryKind>::new()
        }
    }
}

pub HotlistVersion: RefVersion<'input> = {
    "Opera Hotlist version" <v:Version> => v
};

pub HotlistOptions: ast::Options<'input> = {
    "Options:" <mut vo:SingleOp*> =>? {
        let mut encoding: Option<ast::Encoding> = None;

        for o in vo {
            match o {
                ast::SingleOp::Encoding(enc) => {
                    encoding = Some(enc);
                }
            }
        }

        let encoding = encoding.ok_or(ParseError::User {
            error: lexer::LexerError::UserError(ast::HotlistError::RequiredFieldMissing("encoding"))
        })?;

        Ok(ast::Options {
            encoding
        })
    }
}

pub(crate) SingleOp: ast::SingleOp<'input> = {
    "encoding" "=" <enc:Encoding> "," "version" "=" <v:Version> => {
        let encv = match enc {
            ast::Encoding::Utf8(_) => ast::Encoding::Utf8(v)
        };
        ast::SingleOp::Encoding(encv)
    },
}

Encoding: ast::Encoding<'input> = {
    "utf8" => ast::Encoding::Utf8(RefVersion::from("0.0").unwrap())
}

Version: RefVersion<'input> = {
    <s:Version_> => RefVersion::from(s).unwrap(),
    <s:Integer_> => RefVersion::from(s).unwrap()
}

//NoteBody_: () = <s:r"[^\n]*."> => unimplemented!();

extern {
    type Location = usize;
    type Error = lexer::LexerError<'input>; // lexgen and lalrpop diverge in syntax in
                                            // this respect; lexgen needs LHS lifetime, lalrpop
                                            // doesn't.

    enum lexer::Tok<'input> {
        // Literals
        "Opera Hotlist version" => lexer::Tok::HotlistVersion,
        "Options:" => lexer::Tok::Options,
        "encoding" => lexer::Tok::Encoding,
        "version" => lexer::Tok::EncodingVersion,
        "utf8" => lexer::Tok::Utf8,
        "=" => lexer::Tok::Equal,
        "#NOTE" => lexer::Tok::NoteHeader,
        "ID" => lexer::Tok::Id,
        "UNIQUEID" => lexer::Tok::UniqueId,
        "NAME" => lexer::Tok::Name,
        "URL" => lexer::Tok::Url,
        "CREATED" => lexer::Tok::Created,
        "," => lexer::Tok::Comma,
        "EXPANDED" => lexer::Tok::Expanded,
        "TRASH FOLDER"  => lexer::Tok::TrashFolder,
        "YES"  => lexer::Tok::Yes,
        "NO" => lexer::Tok::No,
        "FOLDER" => lexer::Tok::Folder,
        "-" => lexer::Tok::FolderEnd,

        // Regex-based
        Version_ => lexer::Tok::Version(<&'input str>),
        Integer_ => lexer::Tok::Integer(<&'input str>),
        Uuid_ => lexer::Tok::Uuid(<&'input str>),
        UrlBody_ => lexer::Tok::UrlBody(<&'input str>),
        NoteBody_ => lexer::Tok::NoteBody(<&'input str>),
    }
}
